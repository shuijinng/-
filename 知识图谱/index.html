<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ğŸ¬ ç”µå½±çŸ¥è¯†å›¾è°± 3D æ ‡ç­¾äº‘</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Microsoft YaHei", "SimHei", "PingFang SC", sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
    }

    header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 20px;
      text-align: center;
      z-index: 10;
      pointer-events: none;
      background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
    }

    h1 {
      font-size: 2.2em;
      color: #fff;
      text-shadow: 0 0 10px rgba(0, 200, 255, 0.8);
    }

    /* === å·¦ä¸Šè§’æ‚¬æµ®åŠŸèƒ½é¢æ¿ === */
    .floating-panel {
      position: absolute;
      top: 80px;
      left: 20px;
      width: 340px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 14px;
      padding: 16px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(79, 195, 247, 0.4);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      color: #fff;
      font-size: 0.95em;
      z-index: 10;
      pointer-events: auto;
      transition: transform 0.3s ease;
    }

    .floating-panel:hover {
      transform: translateY(-2px);
    }

    .floating-panel h3 {
      color: #4fc3f7;
      margin-bottom: 8px;
      font-size: 1.1em;
      font-weight: 600;
    }

    .floating-panel textarea,
    .floating-panel input[type="text"] {
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 0.95em;
      resize: vertical;
      height: 80px;
      margin-bottom: 8px;
    }

    .floating-panel input[type="text"] {
      height: 40px;
    }

    .floating-panel button {
      margin-top: 8px;
      padding: 8px 16px;
      background: #4fc3f7;
      color: #000;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      transition: 0.2s;
      width: 100%;
    }

    .floating-panel button:hover {
      background: #03a9f4;
      color: white;
    }

    /* åˆ†éš”çº¿ */
    .divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.2);
      margin: 12px 0;
    }

    /* === 3D å®¹å™¨ === */
    #wordcloud-container {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    /* === ä¿¡æ¯é¢æ¿ï¼ˆå³ä¾§ï¼‰=== */
    #info-panel {
      position: fixed;
      right: -1400px;
      top: 100px;
      width: 1400px;
      max-width: 90vw;
      height: 90vh;
      max-height: 800px;
      background: rgba(0, 0, 0, 0.85);
      border-radius: 16px;
      padding: 24px;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 40px rgba(0, 200, 255, 0.3);
      border: 1px solid rgba(0, 200, 255, 0.4);
      overflow-y: auto;
      z-index: 100;
      font-size: 1em;
      transition: right 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
    }

    #info-panel.visible {
      right: 20px;
    }

    #info-panel h3 {
      font-size: 1.3em;
      color: #4fc3f7;
      margin-bottom: 12px;
      border-bottom: 2px solid #4fc3f7;
      padding-bottom: 8px;
    }

    #answer {
      line-height: 1.7;
      color: #e0f7fa;
      white-space: pre-line;
    }

    #graph {
      width: 100%;
      height: 600px;
      margin-top: 20px;
      border-radius: 12px;
      background: #111;
      box-shadow: 0 0 15px rgba(0, 200, 255, 0.1);
    }

    .loading {
      color: #4fc3f7;
      font-style: italic;
    }

    /* === å…³é—­æŒ‰é’® === */
    #close-panel {
      position: absolute;
      top: 12px;
      right: 16px;
      width: 32px;
      height: 32px;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.7);
      font-size: 1.5em;
      font-weight: bold;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(4px);
      opacity: 0.8;
      z-index: 100;
    }

    #close-panel:hover {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      transform: scale(1.1);
      opacity: 1;
    }

    #close-panel:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(79, 195, 247, 0.6);
    }

    footer {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      color: rgba(255, 255, 255, 0.4);
      font-size: 0.9em;
      pointer-events: none;
    }

    /* === å“åº”å¼é€‚é… === */
    @media (max-width: 768px) {
      .floating-panel {
        left: 10px;
        width: 280px;
      }
      #info-panel {
        width: 280px;
      }
      #info-panel.visible {
        right: 10px;
      }
      h1 { font-size: 1.6em; }
    }
  </style>
</head>
<body>

  <header>
    <h1>ğŸ¬ ç”µå½±çŸ¥è¯†å›¾è°± 3D æ ‡ç­¾äº‘</h1>
  </header>

  <!-- === å·¦ä¸Šè§’æ‚¬æµ®åŠŸèƒ½é¢æ¿ === -->
  <div class="floating-panel">
    <!-- åŠŸèƒ½1ï¼šè¾“å…¥ä¸€æ®µè¯æå–å®ä½“ -->
    <div class="input-section">
      <h3>ğŸ“ æå–å®ä½“</h3>
      <textarea id="input-text" placeholder="ä¾‹å¦‚ï¼šæˆ‘æƒ³çœ‹æ±¤å§†Â·æ±‰å…‹æ–¯ä¸»æ¼”çš„ç”µå½±ã€Šé˜¿ç”˜æ­£ä¼ ã€‹"></textarea>
      <button onclick="extractEntitiesFromText()">ğŸ” æå–å¹¶æŸ¥è¯¢</button>
    </div>

    <!-- åˆ†éš”çº¿ -->
    <div class="divider"></div>

    <!-- åŠŸèƒ½2ï¼šç‹¬ç«‹æœç´¢æ¡† -->
    <div class="search-section">
      <h3>ğŸ” æœç´¢å®ä½“</h3>
      <input type="text" id="search-input" placeholder="ç”µå½± / äººç‰© / å…¬å¸..." />
      <button onclick="searchEntity()">ğŸ” æœç´¢</button>
    </div>
  </div>

  <!-- === 3D æ ‡ç­¾äº‘å®¹å™¨ === -->
  <div id="wordcloud-container"></div>

  <!-- === ä¿¡æ¯é¢æ¿ï¼ˆå³ä¾§ï¼‰=== -->
  <div id="info-panel">
    <button id="close-panel" aria-label="å…³é—­é¢æ¿">Ã—</button>
    <div id="answer">ğŸ“Œ ç‚¹å‡»æ ‡ç­¾æˆ–ä½¿ç”¨ä¸Šæ–¹åŠŸèƒ½æŸ¥çœ‹ç›¸å…³ä¿¡æ¯</div>
    <div id="graph" style="display: none;"></div>
  </div>

  <footer>ğŸ” ä½¿ç”¨é¼ æ ‡æ‹–æ‹½æ—‹è½¬è§†è§’ï¼Œæ»šè½®ç¼©æ”¾</footer>

  <!-- å¼•å…¥ Vis.js ç”¨äºçŸ¥è¯†å›¾è°± -->
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <link href="https://unpkg.com/vis-network/styles/vis-network.min.css" rel="stylesheet" type="text/css" />

  <!-- ä¸»é€»è¾‘ -->
  <script type="module">
    import * as THREE from './node_modules/three/build/three.module.js';
    import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';
    import { Text } from './node_modules/troika-three-text/dist/troika-three-text.esm.js';

    // === å…¨å±€å˜é‡ ===
    let scene, camera, renderer, controls;
    let network = null;
    const tagObjects = [];
    const infoPanel = document.getElementById('info-panel');
    let allEntityNames = [];

    // === ä»åç«¯åŠ è½½æ‰€æœ‰å®ä½“å ===
    async function loadEntities() {
      try {
        const res = await fetch("/api/entities");
        const data = await res.json();
        if (data.success) {
          allEntityNames = data.names;
          console.log(`âœ… åŠ è½½ ${data.count} ä¸ªå®ä½“ç”¨äºè¡¥å…¨`);
          return data.names;
        } else {
          console.warn("âš ï¸ åç«¯è¿”å› success: false", data);
          return [];
        }
      } catch (e) {
        console.error("âŒ åŠ è½½å®ä½“å¤±è´¥:", e);
        return [];
      }
    }

    // === æå–è¾“å…¥æ–‡æœ¬ä¸­çš„å®ä½“ ===
async function extractEntitiesFromText() {
  const text = document.getElementById("input-text").value.trim();
  if (!text) return alert("è¯·è¾“å…¥ä¸€æ®µè¯ï¼");

  // æ˜¾ç¤ºåŠ è½½ä¸­
  showAnswer(`<span class="loading">ğŸ” æ­£åœ¨æå–å®ä½“...</span>`, null);
  infoPanel.classList.add('visible');

  try {
    const res = await fetch("/api/extract_and_query", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text }),
    });
    const data = await res.json();

    if (data.success) {
      // æ„é€ æ˜¾ç¤ºå†…å®¹
      const personList = data.entities.person.length > 0 ? `<br>ğŸ‘¤ NAME: ${data.entities.person.join(', ')}` : '';
      const placeList = data.entities.place.length > 0 ? `<br>ğŸ“ åœ°å: ${data.entities.place.join(', ')}` : '';
      const orgList = data.entities.organization.length > 0 ? `<br>ğŸ¢ æœºæ„å: ${data.entities.organization.join(', ')}` : '';

      const resultHtml = `
        ğŸ“ è¾“å…¥æ–‡æœ¬ï¼š<br><em style="color:#aaa;">${data.text}</em>
        <br><br>
        ${personList}
        ${placeList}
        ${orgList}
        <br><br>
        <strong>${data.message}</strong>
      `;
      showAnswer(resultHtml, null); // ç¬¬äºŒä¸ªå‚æ•°ä¼  nullï¼Œä¸æ˜¾ç¤ºå›¾è°±
    } else {
      showAnswer(data.error || "âš ï¸ æœªæå–åˆ°ä»»ä½•å®ä½“ã€‚", null);
    }
  } catch (error) {
    showAnswer(`âŒ è¯·æ±‚å¤±è´¥ï¼š${error.message}`, null);
    console.error("Fetch error:", error);
  }
}
    // === æœç´¢å®ä½“ ===
    function searchEntity() {
      const query = document.getElementById("search-input").value.trim();
      if (!query) return alert("è¯·è¾“å…¥è¦æœç´¢çš„å®ä½“åç§°ï¼");
      askQuestion(query);
    }

    // === æ˜¾ç¤ºå›ç­”å’Œå›¾è°± ===
    function showAnswer(answer, graphData) {
      const answerDiv = document.getElementById("answer");
      const graphDiv = document.getElementById("graph");
      answerDiv.innerHTML = answer;
      graphDiv.style.display = graphData ? "block" : "none";
      if (network) network.destroy();
      if (graphData) drawGraph(graphData);
    }

    // === å‘åç«¯æé—® ===
    async function askQuestion(entity) {
      showAnswer(`<span class="loading">ğŸ” æ­£åœ¨æŸ¥è¯¢ <strong>${entity}</strong> çš„ç›¸å…³ä¿¡æ¯...</span>`, null);
      try {
        const res = await fetch("/ask", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ question: entity }),
        });
        const data = await res.json();

        if (data.answer && data.graph) {
          showAnswer(data.answer, data.graph);
        } else {
          showAnswer(data.answer || "âš ï¸ æœªè·å–åˆ°ç»“æœã€‚", null);
        }
        infoPanel.classList.add('visible');
      } catch (error) {
        showAnswer(`âŒ è¯·æ±‚å¤±è´¥ï¼š${error.message}`, null);
        console.error("Fetch error:", error);
      }
    }

    // === åˆ›å»º 3D æ–‡æœ¬æ ‡ç­¾ ===
    function createTag(text, x, y, z, onClick) {
      const tag = new Text();
      tag.text = text;
      tag.fontSize = 1.6;

      const hue = Math.random();
      const saturation = 0.8;
      const lightness = 0.7;
      const randomColor = new THREE.Color().setHSL(hue, saturation, lightness);

      tag.material = new THREE.MeshStandardMaterial({
        color: randomColor,
        metalness: 0.3,
        roughness: 0.4
      });
      tag.anchorX = 'center';
      tag.anchorY = 'middle';
      tag.position.set(x, y, z);
      tag.userData = { text, onClick, isBillboard: true };

      scene.add(tag);
      tagObjects.push(tag);
      return tag;
    }

    // === åˆå§‹åŒ– 3D æ ‡ç­¾äº‘ ===
    async function init3DWordCloud(names) {
      const container = document.getElementById("wordcloud-container");
      while (container.firstChild) container.removeChild(container.firstChild);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.z = 25;

      const ambientLight = new THREE.AmbientLight(0x404040, 1);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(10, 10, 10).normalize();
      scene.add(directionalLight);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.5;

      const radius = 14;
      names.forEach((name, i) => {
        const phi = Math.acos(-1 + (2 * i) / names.length);
        const theta = Math.sqrt(names.length * Math.PI) * phi;
        const x = radius * Math.cos(theta) * Math.sin(phi);
        const y = radius * Math.sin(theta) * Math.sin(phi);
        const z = radius * Math.cos(phi);
        createTag(name, x, y, z, () => askQuestion(name));
      });

      renderer.domElement.addEventListener('click', onClick);

      function animate() {
        requestAnimationFrame(animate);
        scene.rotation.y += 0.001;
        tagObjects.forEach(tag => {
          if (tag.userData.isBillboard) {
            tag.lookAt(camera.position);
          }
        });
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      function onWindowResize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }

      // === å…³é—­é¢æ¿æŒ‰é’®äº‹ä»¶ ===
      document.getElementById('close-panel').addEventListener('click', () => {
        infoPanel.classList.remove('visible');
      });

      window.addEventListener('resize', () => {
        setTimeout(onWindowResize, 100);
      }, { passive: true });
    }

    // === é¼ æ ‡ç‚¹å‡»äº‹ä»¶ ===
    function onClick(event) {
      const mouse = new THREE.Vector2();
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(tagObjects);
      if (intersects.length > 0) {
        const tag = intersects[0].object;
        if (tag.userData.onClick) {
          tag.userData.onClick();
        }
      }
    }

    // === ç»˜åˆ¶çŸ¥è¯†å›¾è°± ===
    function drawGraph(graphData) {
      const container = document.getElementById("graph");
      const data = {
        nodes: new vis.DataSet(graphData.nodes),
        edges: new vis.DataSet(graphData.edges)
      };

      const options = {
        nodes: {
          shape: 'dot',
          size: 18,
          font: { size: 14, color: '#ffffff', face: 'Microsoft YaHei' },
          borderWidth: 2,
          shadow: true
        },
        edges: {
  color: { 
    color: '#bbbbbb',     // è¾¹çš„é¢œè‰²ï¼ˆæµ…ç°è‰²ï¼‰
    highlight: '#ffffff'  // é¼ æ ‡æ‚¬åœæ—¶è¾¹çš„é¢œè‰²
  },
  font: {
    size: 10,              // å­—ä½“æ›´å°ï¼ˆæ›´ç»†ï¼‰
    color: '#ffffff',      // å­—ä½“é¢œè‰²ï¼šçº¯ç™½ï¼ˆæ›´æ¸…æ™°ï¼‰
    face: 'Microsoft YaHei', // ä½¿ç”¨æ¸…æ™°å­—ä½“ï¼ˆå¾®è½¯é›…é»‘ï¼‰
    background: 'rgba(0, 0, 0, 0.5)', // å¯é€‰ï¼šåŠ ä¸€ä¸ªåŠé€æ˜é»‘åº•ï¼Œè®©æ–‡å­—æ›´çªå‡º
    strokeWidth: 0,        // æ–‡å­—æè¾¹å®½åº¦ï¼ˆè®¾ä¸º0ï¼Œæ›´å¹²å‡€ï¼‰
    align: 'horizontal',   // æ–‡å­—æ°´å¹³æ˜¾ç¤ºï¼ˆé¿å…æ—‹è½¬ï¼‰
    vadjust: -2            // å¾®è°ƒæ–‡å­—å‚ç›´ä½ç½®ï¼Œé¿å…å’Œçº¿é‡å 
  },
  arrows: { 
    to: { 
      enabled: true, 
      scaleFactor: 0.7     // ç®­å¤´å°ä¸€ç‚¹ï¼Œæ›´åè°ƒ
    } 
  },
  smooth: true,            // æ›²çº¿æ›´å¹³æ»‘
  shadow: true,            // å¼€å¯é˜´å½±ï¼Œæå‡å±‚æ¬¡æ„Ÿ
  width: 1                 // è¾¹çº¿ç»†ä¸€ç‚¹
},
        groups: {
          movie: { color: { background: '#e91e63', border: '#c2185b' }, shape: 'ellipse' },
          person: { color: { background: '#4caf50', border: '#388e3c' }, shape: 'icon', icon: { face: 'FontAwesome', code: '\uf007' } },
          company: { color: { background: '#2196f3', border: '#1976d2' }, shape: 'box' }
        },
        physics: {
          repulsion: {
            nodeDistance: 140,
            nodeRepulsion: 1000  // âœ… å·²ä¿®æ­£ä¸º nodeRepulsion
          },
          stabilization: {
            iterations: 180
          }
        },
        interaction: { hover: true }
      };

      network = new vis.Network(container, data, options);
    }

    // === å¯åŠ¨å…¥å£ ===
    window.addEventListener('load', async () => {
      const names = await loadEntities();
      setTimeout(() => init3DWordCloud(names), 100);
    });

    // === æš´éœ²å‡½æ•°åˆ°å…¨å±€ä½œç”¨åŸŸï¼ˆä¾› HTML onclick ä½¿ç”¨ï¼‰===
    window.extractEntitiesFromText = extractEntitiesFromText;
    window.searchEntity = searchEntity;
  </script>
</body>
</html>